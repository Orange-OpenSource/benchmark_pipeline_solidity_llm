Name;Prompt
ComplexStorage;"Please write a smart contract in Solidity to manage and interact with user and product data.
It should pass the following tests:
```js
const { expect } = require(""chai"");

describe(""ComplexStorage"", function () {
  let complexStorage;
  let owner;
  let addr1;
  let addr2;
  let addrs;

  beforeEach(async function () {
    [owner, addr1, addr2, ...addrs] = await ethers.getSigners();
    const ComplexStorage = await ethers.getContractFactory(""ComplexStorage"");
    complexStorage = await ComplexStorage.deploy();
  });

  describe(""User registration"", function () {
    it(""should register a user and retrieve the profile"", async function () {
      await complexStorage.registerUser(""Alice"", 30, { from: addr1.address });
      const userProfile = await complexStorage.getUserProfile(addr1.address);
      expect(userProfile.name).to.equal(""Alice"");
      expect(userProfile.age).to.equal(30);
    });

    it(""should emit a NewUserRegistered event when a new user is registered"", async function () {
      await expect(complexStorage.connect(addr1).registerUser(""Bob"", 25))
        .to.emit(complexStorage, ""NewUserRegistered"")
        .withArgs(addr1.address);
    });
  });

  describe(""Product management"", function () {
    it(""should add a product"", async function () {
      await complexStorage.connect(owner).addProduct(""Laptop"", 1500);
      const product = await complexStorage.products(0);
      expect(product.name).to.equal(""Laptop"");
      expect(product.price).to.equal(1500);
      expect(product.isAvailable).to.be.true;
    });

    it(""should emit a NewProductAdded event when a new product is added"", async function () {
      await expect(complexStorage.connect(owner).addProduct(""Phone"", 500))
        .to.emit(complexStorage, ""NewProductAdded"")
        .withArgs(""Phone"", 500);
    });
  });

  describe(""Access control"", function () {
    it(""should not allow adding products when paused"", async function () {
      await complexStorage.connect(owner).paused(true);
      await expect(complexStorage.connect(owner).addProduct(""Tablet"", 300))
        .to.be.revertedWith(""Contract is paused"");
      await complexStorage.connect(owner).paused(false); // Reset state
    });
  });
});
```
Write only the code. Don't use any external dependencies."
Escrow;"Please write a smart contract in Solidity that acts as an escrow service for transactions between two parties. The contract should securely hold Ether until predefined conditions are met, such as the delivery of goods or completion of services. 
It should pass the following tests:
```js
const { expect } = require(""chai"");
const { ethers } = require(""hardhat"");

describe(""Escrow"", function () {
    let Escrow;
    let escrow;
    let buyer, seller, arbitrator;

    beforeEach(async function () {
        [buyer, seller, arbitrator] = await ethers.getSigners();
        Escrow = await ethers.getContractFactory(""Escrow"");

        escrow = await Escrow.deploy(seller.address, arbitrator.address);
    });

    it(""should allow deposits and update balance correctly"", async function () {
        const depositAmount = ethers.parseEther(""1.0""); // 1 ether
        await escrow.connect(buyer).deposit({ value: depositAmount });
        expect(await escrow.balance()).to.equal(depositAmount);
    });

    it(""should allow approvals from different parties"", async function () {
        await escrow.connect(seller).approve();
        expect(await escrow.getApprovalStatus(seller.address)).to.be.true;
    });

    it(""should allow initiating a dispute"", async function () {
        await escrow.connect(buyer).dispute();
        expect(await escrow.disputeActive()).to.be.true;
    });

    it(""should allow the arbitrator to resolve a dispute in favor of the seller"", async function () {
        const depositAmount = ethers.parseEther(""2.0"");
        await escrow.connect(buyer).deposit({ value: depositAmount });
        await escrow.connect(buyer).dispute();
        const initialSellerBalance = await ethers.provider.getBalance(seller.address);
        await escrow.connect(arbitrator).resolve(true, buyer.address);
        const finalSellerBalance = await ethers.provider.getBalance(seller.address);
        expect(await escrow.balance()).to.equal(0);
        expect(finalSellerBalance-initialSellerBalance).to.equal(depositAmount);
        expect(await escrow.disputeActive()).to.be.false;
    });

    it(""should allow the arbitrator to resolve a dispute in favor of the buyer"", async function () {
        const depositAmount = ethers.parseEther(""3.0"");
        await escrow.connect(buyer).deposit({ value: depositAmount });
        await escrow.connect(buyer).dispute();
        const initialBuyerBalance = await ethers.provider.getBalance(buyer.address);
        await escrow.connect(arbitrator).resolve(false, buyer.address);
        const finalBuyerBalance = await ethers.provider.getBalance(buyer.address);
        expect(await escrow.balance()).to.equal(0);
        expect(finalBuyerBalance).to.be.closeTo(initialBuyerBalance+(depositAmount), ethers.parseEther(""0.01""));
        expect(await escrow.disputeActive()).to.be.false;
    });

    it(""should only allow the arbitrator to resolve disputes"", async function () {
        await escrow.connect(buyer).dispute();
        await expect(escrow.connect(seller).resolve(true, buyer.address)).to.be.revertedWith(""Only arbitrator can call this."");
    });
});
```
Write only the code. Don't use any external dependencies."
LoyaltyReward;"Please write a smart contract in Solidity that automates the tracking of customer purchases and the allocation of rewards points. It enables customers to earn points based on their spending, which can be redeemed according to predefined terms, enhancing customer engagement and loyalty efficiently.
It should pass the following tests:
```js
const { expect } = require(""chai"");
const { ethers } = require(""hardhat"");

describe(""LoyaltyRewards"", function () {
  let LoyaltyRewards;
  let loyaltyRewards;
  let owner;
  let customer1;
  let customer2;

  beforeEach(async function () {
    [owner, customer1, customer2] = await ethers.getSigners();
    LoyaltyRewards = await ethers.getContractFactory(""LoyaltyRewardsSmartContract"");
    loyaltyRewards = await LoyaltyRewards.deploy();
    //await loyaltyRewards.deployed();
  });

  describe(""Deployment"", function () {
    it(""Should set the right owner"", async function () {
      expect(await loyaltyRewards.owner()).to.equal(owner.address);
    });
  });

  describe(""Customer Registration"", function () {
    it(""Should allow the owner to register customers"", async function () {
      await loyaltyRewards.registerCustomer(customer1.address);
      expect(await loyaltyRewards.registeredCustomers(customer1.address)).to.be.true;
    });

    it(""Should not allow non-owner to register customers"", async function () {
      await expect(
        loyaltyRewards.connect(customer1).registerCustomer(customer2.address)
      ).to.be.revertedWith(""Only owner can call this function"");
    });
  });

  describe(""Earning Points"", function () {
    beforeEach(async function () {
      await loyaltyRewards.registerCustomer(customer1.address);
    });

    it(""Should allow registered customers to earn points"", async function () {
      await loyaltyRewards.earnPoints(customer1.address, 1000);
      expect(await loyaltyRewards.points(customer1.address)).to.equal(10); // 1 point per 100 units spent
    });

    it(""Should not allow unregistered customers to earn points"", async function () {
      await expect(
        loyaltyRewards.earnPoints(customer2.address, 1000)
      ).to.be.revertedWith(""Customer not registered"");
    });
  });

  describe(""Redeeming Points"", function () {
    beforeEach(async function () {
      await loyaltyRewards.registerCustomer(customer1.address);
      await loyaltyRewards.earnPoints(customer1.address, 1000);
    });

    it(""Should allow registered customers to redeem points"", async function () {
      await loyaltyRewards.redeemPoints(customer1.address, 5);
      expect(await loyaltyRewards.points(customer1.address)).to.equal(5);
    });

    it(""Should not allow customers to redeem more points than they have"", async function () {
      await expect(
        loyaltyRewards.redeemPoints(customer1.address, 15)
      ).to.be.revertedWith(""Insufficient points"");
    });
  });

  describe(""Points Balance"", function () {
    beforeEach(async function () {
      await loyaltyRewards.registerCustomer(customer1.address);
      await loyaltyRewards.earnPoints(customer1.address, 1000);
    });

    it(""Should return the correct points balance for a customer"", async function () {
      expect(await loyaltyRewards.getPoints(customer1.address)).to.equal(10);
    });
  });
});
```
Write only the code. Don't use any external dependencies."
MultiSignature;"Please write a smart contract in Solidity that enhances the security of asset management by requiring multiple parties to approve a transaction before it can be executed. This contract acts as a wallet that holds and manages digital assets. The contract allows for the definition of a predetermined number of required approvals, which can be set during contract deployment or modified later by authorized parties. To initiate a transaction, a party submits a request to the contract specifying the recipient address, the amount or asset to be transferred, and any additional data required. Once the request is submitted, it enters a pending state. Authorized parties, typically defined as a group of individuals or entities, can then review the pending transaction and individually provide their approval by signing the transaction using their private keys. The contract keeps track of the number of approvals received. Once the required number of approvals is reached, the contract automatically executes the transaction, transferring the specified assets to the recipient address. If the required number of approvals is not met within a specified time frame, the transaction request can be canceled.
It should pass the following tests:
```js
import { ethers } from ""hardhat"";
import { expect } from ""chai"";

describe(""MultiSignatureWallet"", function () {
  let multiSigWallet;
  let owner1;
  let owner2;
  let recipient;
  let amount;
  let transactionId;

  before(async function () {
    [owner1, owner2, recipient] = await ethers.getSigners();

    const MultiSignatureWallet = await ethers.getContractFactory(""MultiSignatureWallet"");
    multiSigWallet = await MultiSignatureWallet.deploy([owner1.address, owner2.address], 2);
  });

  it(""should submit a transaction"", async function () {
    amount = ethers.utils.parseEther(""1"");
    transactionId = await multiSigWallet.submitTransaction(recipient.address, amount, 1);

    expect(transactionId).to.equal(0);
  });

  it(""should approve a transaction"", async function () {
    await multiSigWallet.connect(recipient).approveTransaction(transactionId);

    const isApproved = await multiSigWallet.approvedTransactions(transactionId);
    expect(isApproved).to.be.true;
  });

  it(""should execute a transaction"", async function () {
    const balanceBefore = await ethers.provider.getBalance(recipient.address);

    await multiSigWallet.executeTransaction(transactionId);

    const balanceAfter = await ethers.provider.getBalance(recipient.address);
    expect(balanceAfter.sub(balanceBefore)).to.equal(amount);
  });
});
```
Write only the code. Don't use any external dependencies."
Ownership;"Please write a simple ownership management smart contract using Solidity.
It should pass the following tests:
```js
const { expect } = require(""chai"");
const { ethers } = require(""hardhat"");

describe(""Ownership"", function () {
    let Ownership;
    let ownership;
    let initialOwner, newOwner;

    beforeEach(async function () {
        [initialOwner, newOwner] = await ethers.getSigners();
        Ownership = await ethers.getContractFactory(""Ownership"");
        ownership = await Ownership.deploy();
    });

    it(""should set the creator as the initial owner"", async function () {
        let owner = await ownership.getOwner();
        expect(owner).to.equal(initialOwner.address, ""The initial owner should be the contract creator"");
    });

    it(""should change owner"", async function () {
        await ownership.connect(initialOwner).changeOwner(newOwner.address);
        let owner = await ownership.getOwner();
        expect(owner).to.equal(newOwner.address, ""The owner should be changed to the new owner"");
    });

    it(""should prevent non-owners from changing the owner"", async function () {
        try {
            await ownership.connect(newOwner).changeOwner(initialOwner.address);
            expect.fail(""Expected revert when non-owner tries to change owner"");
        } catch (error) {
            expect(error.message).to.include(""revert"", ""Expected revert when non-owner tries to change owner"");
        }
        let owner = await ownership.getOwner();
        expect(owner).to.equal(newOwner.address, ""The owner should remain unchanged after an unauthorized attempt"");
    });
});
```
Write only the code. Don't use any external dependencies."
PaymentSplit;"Please write a smart contract in Solidity designed to automatically divide incoming payments among multiple parties based on predefined percentages. This functionality ensures that each participant receives their fair share of the total funds according to the agreed-upon distribution rules, directly into their respective wallets.
It should pass the following tests:
```js
const { expect } = require(""chai"");
const { ethers } = require(""hardhat"");

describe(""PaymentSplitterContract"", function () {
  let PaymentSplitter;
  let paymentSplitter;
  let owner;
  let addr1;
  let addr2;
  let addrs;

  beforeEach(async function () {
    PaymentSplitter = await ethers.getContractFactory(""PaymentSplitterContract"");
    [owner, addr1, addr2, ...addrs] = await ethers.getSigners();
    paymentSplitter = await PaymentSplitter.deploy([addr1.address, addr2.address], [50, 50]);
  });

  describe(""Deployment"", function () {
    it(""Should set the right addresses and percentages"", async function () {
      expect(await paymentSplitter.parties(0)).to.equal(addr1.address);
      expect(await paymentSplitter.percentages(0)).to.equal(50);
      expect(await paymentSplitter.parties(1)).to.equal(addr2.address);
      expect(await paymentSplitter.percentages(1)).to.equal(50);
    });
  });

  describe(""Payment distribution"", function () {
    it(""Should distribute payments according to predefined percentages"", async function () {
      const paymentAmount = ethers.utils.parseEther(""1""); // 1 ETH

      // Owner sends 1 ETH to the contract
      await owner.sendTransaction({
        to: paymentSplitter.address,
        value: paymentAmount
      });

      // Check balances after payment
      const balance1 = await ethers.provider.getBalance(addr1.address);
      const balance2 = await ethers.provider.getBalance(addr2.address);

      // Each address should receive 0.5 ETH
      expect(balance1).to.equal(ethers.parseEther(""0.5""));
      expect(balance2).to.equal(ethers.parseEther(""0.5""));
    });

    it(""Should revert if the percentages do not sum up to 100"", async function () {
      await expect(PaymentSplitter.deploy([addr1.address, addr2.address], [30, 40])).to.be.revertedWith(""Percentages must sum up to 100"");
    });
  });
});
```
Write only the code. Don't use any external dependencies."
SimpleStorage;"Please write a smart contract in Solidity that stores and reads a value.
It should pass the following tests:
```js
const { expect } = require(""chai"");
const { ethers } = require(""hardhat"");

describe(""MyContract"", function () {
    let MyContract;
    let myContract;
    let owner;
    beforeEach(async function () {
        [owner] = await ethers.getSigners();
        MyContract = await ethers.getContractFactory(""SimpleStorage"");
        myContract = await MyContract.deploy();
    });

    it(""should store and retrieve a value"", async function () {
        // Store a value
        await myContract.connect(owner).store(123);

        // Retrieve the stored value
        const storedValue = await myContract.retrieve();

        // Assert that the retrieved value is correct
        expect(storedValue).to.equal(123, ""The value 123 was not stored."");
    });
});
```
Write only the code. Don't use any external dependencies."
SupplyChain;"Please write a smart contract in Solidity that records each step of a product's journey from production to delivery. It ensures the authenticity and traceability of goods, enhancing accountability and efficiency in the supply chain.
It should pass the following tests:
```js
const { expect } = require(""chai"");
const { ethers } = require(""hardhat"");

describe(""SupplyChainTracker"", function () {
  let SupplyChain;
  let supplyChain;
  let owner;
  let manufacturer;
  let distributor;
  let retailer;

  beforeEach(async function () {
    SupplyChain = await ethers.getContractFactory(""SupplyChainTracker"");
    [owner, manufacturer, distributor, retailer] = await ethers.getSigners();
    supplyChain = await SupplyChain.deploy();
  });

  describe(""Product lifecycle"", function () {
    it(""Should record production details"", async function () {
      const productId = ""PROD123"";
      const productionDetails = ""Product manufactured on 2021-09-01"";
      await supplyChain.connect(manufacturer).logProduction(productId, productionDetails);

      const recordedDetails = await supplyChain.getProductionDetails(productId);
      expect(recordedDetails).to.equal(productionDetails);
    });

    it(""Should record shipping details"", async function () {
      const productId = ""PROD123"";
      const shippingDetails = ""Product shipped on 2021-09-05"";
      await supplyChain.connect(distributor).logShipping(productId, shippingDetails);

      const recordedDetails = await supplyChain.getShippingDetails(productId);
      expect(recordedDetails).to.equal(shippingDetails);
    });

    it(""Should record delivery details"", async function () {
      const productId = ""PROD123"";
      const deliveryDetails = ""Product delivered on 2021-09-10"";
      await supplyChain.connect(retailer).logDelivery(productId, deliveryDetails);

      const recordedDetails = await supplyChain.getDeliveryDetails(productId);
      expect(recordedDetails).to.equal(deliveryDetails);
    });
  });

  describe(""Access control"", function () {
    it(""Should only allow authorized users to log production"", async function () {
      const productId = ""PROD123"";
      const productionDetails = ""Unauthorized production log attempt"";
      await expect(supplyChain.connect(retailer).logProduction(productId, productionDetails))
        .to.be.revertedWith(""Unauthorized"");
    });

    it(""Should only allow authorized users to log shipping"", async function () {
      const productId = ""PROD123"";
      const shippingDetails = ""Unauthorized shipping log attempt"";
      await expect(supplyChain.connect(manufacturer).logShipping(productId, shippingDetails))
        .to.be.revertedWith(""Unauthorized"");
    });

    it(""Should only allow authorized users to log delivery"", async function () {
      const productId = ""PROD123"";
      const deliveryDetails = ""Unauthorized delivery log attempt"";
      await expect(supplyChain.connect(distributor).logDelivery(productId, deliveryDetails))
        .to.be.revertedWith(""Unauthorized"");
    });
  });
});
```
Write only the code. Don't use any external dependencies."
TokenCreation;"Please write a smart contract in Solidity that facilitates the automated creation of digital tokens, enabling issuers to define crucial parameters like the total supply and specific distribution mechanisms.
It should pass the following tests:
```js
const { expect } = require(""chai"");
const { ethers } = require(""hardhat"");

describe(""TokenCreationContract"", function () {
  let Token;
  let token;
  let owner;
  let addr1;
  let addr2;

  beforeEach(async function () {
    Token = await ethers.getContractFactory(""TokenCreation"");
    [owner, addr1, addr2] = await ethers.getSigners();
    token = await Token.deploy(1000); // Assuming the constructor takes the total supply as a parameter
  });

  describe(""Deployment"", function () {
    it(""Should set the right owner"", async function () {
      expect(await token.owner()).to.equal(owner.address);
    });

    it(""Should assign the total supply of tokens to the owner"", async function () {
      const ownerBalance = await token.balanceOf(owner.address);
      expect(await token.totalSupply()).to.equal(ownerBalance);
    });
  });

  describe(""Transactions"", function () {
    it(""Should transfer tokens between accounts"", async function () {
      // Transfer 50 tokens from owner to addr1
      await token.transfer(addr1.address, 50);
      const addr1Balance = await token.balanceOf(addr1.address);
      expect(addr1Balance).to.equal(50);

      // Transfer 50 tokens from addr1 to addr2
      await token.connect(addr1).transfer(addr2.address, 50);
      const addr2Balance = await token.balanceOf(addr2.address);
      expect(addr2Balance).to.equal(50);
    });

    it(""Should fail if sender doesn�t have enough tokens"", async function () {
      const initialOwnerBalance = await token.balanceOf(owner.address);

      // Try to send 1 more token than the owner has
      await expect(token.connect(addr1).transfer(owner.address, initialOwnerBalance + 1)).to.be.revertedWith(""Not enough tokens"");

      // Owner balance shouldn't have changed.
      expect(await token.balanceOf(owner.address)).to.equal(initialOwnerBalance);
    });
  });

  describe(""Token distribution"", function () {
    it(""Should distribute tokens according to predefined rules"", async function () {
      // Assuming there's a distribute function that distributes 100 tokens to addr1 and 200 to addr2
      await token.distribute([addr1.address, addr2.address], [100, 200]);

      expect(await token.balanceOf(addr1.address)).to.equal(100);
      expect(await token.balanceOf(addr2.address)).to.equal(200);
    });
  });
});
```
Write only the code. Don't use any external dependencies."
Voting;"Please write a simple voting ballot smart contract in Solidity. The contract should allow the owner to create a new ballot with a specific set of candidates. Voters can vote for their preferred candidate once per ballot. The contract should prevent double voting and only allow eligible voters to participate. Include a function to tally the votes and declare the winner.
It should pass the following tests:
```js
const { expect } = require(""chai"");
const { ethers } = require(""hardhat"");

describe(""Voting"", function () {
    let Voting;
    let voting;
    let owner, voter1, voter2;

    beforeEach(async function () {
        [owner, voter1, voter2] = await ethers.getSigners();
        Voting = await ethers.getContractFactory(""votingMistral"");
        voting = await Voting.deploy();

    });

    it(""should allow owner to create a ballot"", async function () {
        await voting.connect(owner).createBallot([""Alice"", ""Bob""]);
        let candidates = await voting.getCandidates(0);
        expect(candidates.length).to.equal(2, ""Ballot should have 2 candidates"");
    });

    it(""should allow a voter to vote"", async function () {
        await voting.connect(owner).addVoter(voter1.address);
        await voting.connect(voter1).vote(0, 0);
        let voteCount = await voting.getVotes(0, 0);
        expect(voteCount).to.equal(1, ""Candidate should have 1 vote"");
    });

    it(""should prevent double voting"", async function () {
        await voting.connect(owner).addVoter(voter1.address);
        await voting.connect(voter1).vote(0, 0);
        try {
            await voting.connect(voter1).vote(0, 0);
            expect.fail(""Expected revert for double voting"");
        } catch (error) {
            expect(error.message).to.include(""revert"", ""Expected revert for double voting"");
        }
    });

    it(""should declare the correct winner"", async function () {
        await voting.connect(owner).addVoter(voter2.address);
        await voting.connect(voter2).vote(0, 1);
        let winner = await voting.getWinner(0);
        expect(winner).to.equal(""Bob"", ""Bob should be the winner"");
    });
});
```
Write only the code. Don't use any external dependencies."
